apiVersion: v1
kind: ConfigMap
metadata:
  name: proxy-router-script
  namespace: {{ .Release.Namespace }}
data:
  proxy-router.py: |
    import socketserver
    import http.server
    import socket
    import urllib.parse
    import time
    import threading

    SQUID_PORTS = list(range(3128, 3148))  # 20 портов
    DELAY_SECONDS = 2
    LOCK = threading.Lock()
    last_used = {}

    class ProxyHandler(http.server.BaseHTTPRequestHandler):
        def do_CONNECT(self):
            self.send_error(405, "CONNECT not supported in this proxy")
            return

        def do_GET(self):
            self.handle_http_proxy()

        def do_POST(self):
            self.handle_http_proxy()

        def handle_http_proxy(self):
            parser_id = self.headers.get("X-Parser-ID", "default")
            squid_port = self.select_port(parser_id)

            if not self.wait_allowed(parser_id, squid_port):
                self.send_error(429, "Too many requests")
                return

            try:
                target = self.path
                parsed = urllib.parse.urlsplit(target)
                host = parsed.hostname
                port = parsed.port or 80

                with socket.create_connection(("127.0.0.1", squid_port)) as proxy_sock:
                    request_line = f"{self.command} {target} {self.request_version}\r\n"
                    proxy_sock.sendall(request_line.encode())

                    for header, value in self.headers.items():
                        proxy_sock.sendall(f"{header}: {value}\r\n".encode())
                    proxy_sock.sendall(b"\r\n")

                    if "Content-Length" in self.headers:
                        content_length = int(self.headers["Content-Length"])
                        body = self.rfile.read(content_length)
                        proxy_sock.sendall(body)

                    self.forward(self.connection, proxy_sock)

            except Exception as e:
                self.send_error(502, f"Proxy error: {e}")

        def select_port(self, parser_id):
            index = abs(hash(parser_id)) % len(SQUID_PORTS)
            return SQUID_PORTS[index]

        def wait_allowed(self, parser_id, port):
            now = time.time()
            key = (parser_id, port)
            with LOCK:
                last = last_used.get(key, 0)
                if now - last >= DELAY_SECONDS:
                    last_used[key] = now
                    return True
                return False

        def forward(self, client_sock, server_sock):
            def pipe(src, dst):
                try:
                    while True:
                        data = src.recv(4096)
                        if not data:
                            break
                        dst.sendall(data)
                finally:
                    try: dst.shutdown(socket.SHUT_RDWR)
                    except: pass
                    dst.close()

            threading.Thread(target=pipe, args=(client_sock, server_sock)).start()
            pipe(server_sock, client_sock)

        def log_message(self, format, *args):
            return

    if __name__ == "__main__":
        server = socketserver.ThreadingTCPServer(("0.0.0.0", 8080), ProxyHandler)
        print("Proxy-router (HTTP mode) started on port 8080")
        server.serve_forever()
